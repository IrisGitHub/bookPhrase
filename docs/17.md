
**《两周自制脚本语言 》读书笔记**

语言处理器大致分为解释器和编译器

解释器：用于执行程序的软件。如果执行的程序由虚拟机器语言或类似的机器语言写成，这种软件也能称为虚拟机。

编译器：能将某种语言写成的程序转换成另一种语言的程序


通常，Java语言首先会通过编译器将源代码转换为Java二进制代码，并将这种虚拟的机器语言保存在文件中，之后，Java虚拟机的解释器将执行这段代码。

不过，大多数Java虚拟机为了提高性能，会在执行过程中通过编译将一部分Java二进制代码直接转换成机器语言使用（这个过程称为动态编译或JIT编译）。转换后的机器语言将被载入内存，有硬件执行，无需解释器。


现代解释器内部常采用各种类型的编译器。

语言处理器内部的处理流程

源代码 —- 词法分析 -—> 单词排列 —- 语法分析 -— > 抽象语法树 —- 编译器/解释器 -— >其他语言程序/程序执行结果。


设计Stone语言的语法规则


分割单词


语言处理器的第一个组成部分是词法分分析器，将字符串中的字符以单词为单位分组，切割成多个子字符串。

借助Java语言来设计Stone语言的处理器

  

1、设计词法分析器。考虑每一种类型的单词的定义，规定怎样的字符串才能构成 一个单词

 Stone语言支持三种类型的单词：标识符、整型字面量、字符串字面量。

  借助正则表达式来定义Stone语言的单词：

  整型字面量：\[0-9\]+。从0-9中取出一个数字

  标识符：

  至少需要一个字母、数字或下划线，且首字母不能是数字：\[A-Z\_a-z\]\[A-Z\_a-z0-9\]\*   

  Stone语言的标识符包括各类符号，所以完整的标识符规则：\[A-Z a-\[A-Z a--9 \*|==|<=|>=|&&|\\|\\||\\p{Punc。其中 \\ p{Punc}表示与任意一个符号字符匹配

  字符串字面量：”(\\\\" |\\\\\\\\|\\\\n|\[^" )\*" 。Java中两个反斜杠代表\\，因此\\\\\\\\表示匹配一个\\。

  

用于表示程序的对象

  

1、抽象语法树定义

*    语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。
    
*    抽象语法树 (AST，Abstract Syntax Tree)是一种用于表示程序结构的树形结构。构造抽象语法树的过程称为语法分析，依然属于语言处理器的前半阶段。其主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处 理左右括号(单词)的配对等问题。
    
*    语法分析的结果能够通过抽象语法树来表示。这一阶段还会 检查程序中是否含有语法错误。
    

  

 本书使用 Java 语言来实现语言处理器，因此选择通过对象与树形结构来表示程序结构。如果用于实现的不是面向对象语言，表示树形结构的方法也会有所不同。如果是 C 语言，则会使 用结构体;如果是 Scheme 语言，则会使用列表。

  

2、使用BNF(巴科斯范式 )或铁路图表示语法

 语法规定了单词的组合规则，例如，双目运算表达式应该由哪些单词组成，或是if语句 应该具有怎样的结构等。而程序设计语言的语法通常会包含诸如if语句的执行方式，或通 过extends继承类时将执行哪些处理等规则。

  

 BNF 是 JohBackus 为表达 Algol 语言的语法而设计的，不过最后大家发现它能用于表达语 言学领域中的 Noam Chomsky 上下文无关文法。

![](%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%20%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.resources/E9CA61A1-4689-4FA7-A5BB-27EC2B32F417.png)

![](%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%20%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.resources/2897F6C4-5D65-4B9E-9741-7D0C816A16D6.png)

在 BNF 的表达规则中，

: 左侧所写的内容能够用于表示与在 : 右侧所写的模式相匹配的单词序列。

例如上图第 1 行的规则中，factor(因子)意指与右侧模式匹配的单词序 列。: 左侧出现的诸如factor这样的符号称为非终结符或元变量。

  

与非终结符相对的是终结符，它们是一些事先规定好的符号，表示各种单词。 : 右侧的模式中也包含了若干个终结符或非终结符。

例如上图第 1 行的规则中，factor能表示 NUMBER(1 个整型字面量单词)，或 由左括号、 expression(表达式)及右括号依次排列而成的单词序列。 expression是一个非终结符，第 3 行对其下了定义。因此，由左括号、与expression匹配的单词序列，及右括号这些单词组成的单词序列能与factor模式匹配。

  

也就是说，与该模式匹配的单词序列就是一个 expression。反之，如果单词序列与模式 expression不匹配，则会发生语法错误(syntax error)。

  

模式中包含非终结符是 BNF 的特征之一。具有循环结构的递归定义 也是 BNF 的一个特征。

  

![](%E3%80%8A%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%20%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.resources/97BBF4C4-B5DF-4C34-80BB-BEB4DDF21AFF.png)

人们有时会用铁路图而不是 BNF 来表示语法规则。图中的圆圈表示终结符，矩形表示非终结符。箭头的分支与 合并表示模式的循环出现或“or ”的含义。

  

3、语法分析与抽象语法树

 语法分析用于查找与模式匹配的单词序列。查找得到的单词序列是一个具有特定含义的单词组。 分组后的单词能继续与其他单词组一起做模式匹配，组成更大的分组。  

  

 通常，抽象语法树用于表示语法分析的 结果，因此需要表现出这些分组之间的包含关系。