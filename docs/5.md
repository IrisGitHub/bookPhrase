
**《学习JavaScript数据结构与算法》笔记**

数组    存储一系列同一种数据类型的值。数组是最简单的内存数据结构

push、pop、unshift、shift、splice、concat、every、some、forEach、map、filter、reduce、reverse、sort、indexOf、lastIndexOf、toString、join

  

栈     遵循后进先出原则的有序集合。

push、pop、peek、isEmpty、clear、size

十进制转化二进制，任意进制转化二进制

  

队列     遵循先进先出原则的一组有序的项

enqueue、dequeue、front、isEmpty、size

优先队列、击鼓传花

  

链表     存储有序的元素集合。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成

append、insert、remove、indexOf、removeAt、isEmpty、size、toString

  

双向链表   链表中，链接是双向的，一个链向下一个元素，另一个链向前一个元素。

  

循环链表   可以像链表一样只有单向引用，也可以向双向链表一样有双向引用。

  

集合   由一组无序且唯一（即不能重复）的项组成

add、remove、has、clear、 size、values

集合操作：并集unionSet、交集intersectionSet、差集differenceSet、子集

  

字典   存储的是【键, 值】，字典也称作映射

set、remove、has、get、clear、size、keys、values

  

散列表 散列算法的作用是尽可能快地在数据结构中找到一个值。HashTable类，也叫HashMap类，是Dictionary类的一种散列表实现方式。散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。

put、remove、get

  

处理散列表中的冲突。有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。

处理冲突有几种方法:

分离链接：为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。

线性探查：当想向表中某个位置加入一个新元素的时候，如果索引 为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试 index+2的位置，以此类推。

  

树   树是一种分层数据的抽象模型。树是图的一种，无环无向图

节点、根节点、父节点、子节点、内部节点、外部节点、子树、深度、度

二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。

  

二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。

insert(key)：向树中插入一个新的键值

search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false

inOrderTraverse：通过中序遍历方式遍历所有节点

preOrderTraverse：通过先序遍历方式遍历所有节点

posetOrderTraverse：通过后序遍历遍历所有节点

min：返回树中最小的值/键

max：返回树中最大的值/键

remove(key)：从树中移除某个键

  

树的遍历 树是指访问树的每个节点并对它们进行某种操作的过程。

中序遍历：中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/24B7C067-CA29-46D3-8CF5-B50515D0F8F8.png)  

                3 5 6 7 8 9 10 11 12 13 14 15 18 20 25

先序遍历：先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/16D48CC2-4B52-4D85-99AF-6793A21010A8.png)  

                11 7 5 3 6 9 8 10 15 13 12 14 20 18 25

后序遍历：后序遍历则是先访问节点的后代节点，再访问节点本身。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/E312E0C1-190D-4FDF-9CA6-963F85F76A0D.png)  

                 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11

搜索最大值和最小值

搜索特定的值

移除一个节点

  

图  网络结构的抽象模型。图是一组由边连接的节点(或顶点)。学习图是重要的，因为任何二元关系都可以用图来表示。

相邻顶点、顶点的度（其相邻顶点的数量）、路径、简单路径（不包含重复的顶点）、环

*   如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。
    
*   图可以是无向的(边没有方向)或是有向的(有向图)。
    
*   如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。
    
*   图还可以是未加权的(目前为止我们看到的图都是未加权的)或是加权的。
    

  

图的表示

邻接矩阵：图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/2A93B47A-FF86-4996-AEBE-5894E23DDAE2.png)  

邻接表：邻接表由图中每个顶点的相邻顶 点列表所组成。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/0A375A08-835C-4CAB-9BB0-CF42C744D5D1.png)  

关联矩阵：在关联矩阵中，矩阵的行表示顶点，列表示边。关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/E68C597A-338C-4E50-9ACF-F7B62F08B96B.png)  

  

创建图类

图的骨架：使用一个数组（vertices 数组）来存储图中所有顶点的名字以及一个字典（adjList字典）来存储邻接表。字典将会使用顶点的名字作为键，邻接顶点列表作为值。

  

图的遍历  和树数据结构类似，我们可以访问图的所有节点。

有两种算法可以对图进行遍历:广度优先搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/E1A16E26-6C21-49D7-81D6-880DC42CF66C.png)  

深度优先搜索：会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶 点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。

  

  

排序和搜索算法

冒泡排序：比较任何两个相邻的项，如果第一个比第二个大，则交换它们。复杂度是O(n2)

选择排序：找到数据结构中的最小值并 2 将其放置在第一位，接着找到第二小的值并将其放在第二位。复杂度为O(n2)

插入排序：每次排一个数组项，以此方式构建最后的排序数组。

归并排序：一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一 个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。复杂度为O(nlogn)。

快速排序：先从数列中取出一个数作为基准数，分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边，再对左右区间重复第二步，直到各区间只有一个数。

顺序或线性搜索：最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。

二分搜索：这个算法要求被搜索的数据结构已排序。选择数组的中间值，如果选中值是待搜索值，那么算法执行完毕；如果待搜索值比选中值要小，则在选中值左边的子数组中寻找；如果待搜索值比选中值要大，则在选种值右边的子数组中寻找。

  

递归

递归并不会无限地执行下去;浏览器会抛出错误，也就是所谓的栈溢出错误(stack overflow error)。根据操作系统和浏览器的不同，具体数值会所有不同，但区别不大。

ECMAScript 6有尾调用优化(tail call optimization)。如果函数内最后一个操作是调用函数，会通过“跳转指令”(jump) 而不是“子程序调用”(subroutine call)来 控制。也就是说，在ECMAScript 6中，没有边界的递归代码可以一直执行下去。

  

动态规划(Dynamic Programming，DP) 一种将复杂问题分解成更小的子问题来解决的优化技术。

注意：动态规划和分而治之(归并排序和快速排序算法中用到的那种)是不 同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答 案，而动态规划则是将问题分解成相互依赖的子问题。

背包问题、最长公共子序列、矩阵链相乘、硬币找零、图的全源最短路径

硬币找零，分解递归得出所有的找零方案，并在程序中通过比较记录下最优解。

  

贪心算法

遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择(当前最好的解)，从而达到全局的最优(全局最优解)。

  

大O表示法  描述算法的性能和复杂程度。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/9D6DE6C1-239D-4088-9ECE-F0A7D52E3462.png)  

如何衡量算法的效率?通常是用资源，例如CPU(时间)占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU(时间)占用。

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/F813E5AD-729D-405C-808A-B3818E39022C.png)  

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/0153A9A4-6CD0-405E-98E1-5A7651DF7FF2.png)  

  

  

![](%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0.resources/F01A9084-F10F-40A3-B06C-64C506604466.png)